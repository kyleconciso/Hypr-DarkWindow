This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    notify.yml
res/
  preview.png
src/
  Helpers.cpp
  Helpers.h
  main.cpp
  OpenGL.cpp.h
  WindowShader.cpp
  WindowShader.h
.gitignore
flake.lock
flake.nix
hyprpm.toml
LICENSE
Makefile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
hyprland/
out/
.vscode/
.envrc
.direnv
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 micha4w

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/OpenGL.cpp.h">
// This file contains functions that were yoinked from hyprland/src/render/OpenGL.cpp
#pragma once

#include <hyprland/src/render/OpenGL.hpp>
#include <hyprland/src/render/shaders/Shaders.hpp>
#include <hyprland/src/helpers/fs/FsUtils.hpp>

#include <hyprutils/string/String.hpp>
#include <hyprutils/path/Path.hpp>

const std::vector<const char*> ASSET_PATHS = {
#ifdef DATAROOTDIR
    DATAROOTDIR,
#endif
    "/usr/share",
    "/usr/local/share",
};

static void logShaderError(const GLuint& shader, bool program, bool silent = false) {
    GLint maxLength = 0;
    if (program)
        glGetProgramiv(shader, GL_INFO_LOG_LENGTH, &maxLength);
    else
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &maxLength);

    std::vector<GLchar> errorLog(maxLength);
    if (program)
        glGetProgramInfoLog(shader, maxLength, &maxLength, errorLog.data());
    else
        glGetShaderInfoLog(shader, maxLength, &maxLength, errorLog.data());
    std::string errorStr(errorLog.begin(), errorLog.end());

    const auto  FULLERROR = (program ? "Screen shader parser: Error linking program:" : "Screen shader parser: Error compiling shader: ") + errorStr;

    Debug::log(ERR, "Failed to link shader: {}", FULLERROR);

    if (!silent)
        g_pConfigManager->addParseError(FULLERROR);
}

static GLuint compileShader(const GLuint& type, std::string src, bool dynamic, bool silent) {
    auto shader = glCreateShader(type);

    auto shaderSource = src.c_str();

    glShaderSource(shader, 1, (const GLchar**)&shaderSource, nullptr);
    glCompileShader(shader);

    GLint ok;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &ok);

    if (dynamic) {
        if (ok == GL_FALSE) {
            logShaderError(shader, false, silent);
            return 0;
        }
    } else {
        if (ok != GL_TRUE)
            logShaderError(shader, false);
        RASSERT(ok != GL_FALSE, "compileShader() failed! GL_COMPILE_STATUS not OK!");
    }

    return shader;
}

static GLuint createProgram(const std::string& vert, const std::string& frag, bool dynamic, bool silent) {
    auto vertCompiled = compileShader(GL_VERTEX_SHADER, vert, dynamic, silent);
    if (dynamic) {
        if (vertCompiled == 0)
            return 0;
    } else
        RASSERT(vertCompiled, "Compiling shader failed. VERTEX nullptr! Shader source:\n\n{}", vert);

    auto fragCompiled = compileShader(GL_FRAGMENT_SHADER, frag, dynamic, silent);
    if (dynamic) {
        if (fragCompiled == 0)
            return 0;
    } else
        RASSERT(fragCompiled, "Compiling shader failed. FRAGMENT nullptr! Shader source:\n\n{}", frag);

    auto prog = glCreateProgram();
    glAttachShader(prog, vertCompiled);
    glAttachShader(prog, fragCompiled);
    glLinkProgram(prog);

    glDetachShader(prog, vertCompiled);
    glDetachShader(prog, fragCompiled);
    glDeleteShader(vertCompiled);
    glDeleteShader(fragCompiled);

    GLint ok;
    glGetProgramiv(prog, GL_LINK_STATUS, &ok);
    if (dynamic) {
        if (ok == GL_FALSE) {
            logShaderError(prog, true, silent);
            return 0;
        }
    } else {
        if (ok != GL_TRUE)
            logShaderError(prog, true);
        RASSERT(ok != GL_FALSE, "createProgram() failed! GL_LINK_STATUS not OK!");
    }

    return prog;
}

static std::string loadShader(const std::string& filename) {
    const auto home = Hyprutils::Path::getHome();
    if (home.has_value()) {
        const auto src = NFsUtils::readFileAsString(home.value() + "/hypr/shaders/" + filename);
        if (src.has_value())
            return src.value();
    }
    for (auto& e : ASSET_PATHS) {
        const auto src = NFsUtils::readFileAsString(std::string{e} + "/hypr/shaders/" + filename);
        if (src.has_value())
            return src.value();
    }
    if (SHADERS.contains(filename))
        return SHADERS.at(filename);
    throw std::runtime_error(std::format("Couldn't load shader {}", filename));
}

static void loadShaderInclude(const std::string& filename, std::map<std::string, std::string>& includes) {
    includes.insert({filename, loadShader(filename)});
}

static void processShaderIncludes(std::string& source, const std::map<std::string, std::string>& includes) {
    for (auto it = includes.begin(); it != includes.end(); ++it) {
        Hyprutils::String::replaceInString(source, "#include \"" + it->first + "\"", it->second);
    }
}

static std::string processShader(const std::string& filename, const std::map<std::string, std::string>& includes) {
    auto source = loadShader(filename);
    processShaderIncludes(source, includes);
    return source;
}

// shader has #include "CM.glsl"
static void getCMShaderUniforms(SShader& shader) {
    shader.uniformLocations[SHADER_SKIP_CM]           = glGetUniformLocation(shader.program, "skipCM");
    shader.uniformLocations[SHADER_SOURCE_TF]         = glGetUniformLocation(shader.program, "sourceTF");
    shader.uniformLocations[SHADER_TARGET_TF]         = glGetUniformLocation(shader.program, "targetTF");
    shader.uniformLocations[SHADER_SRC_TF_RANGE]      = glGetUniformLocation(shader.program, "srcTFRange");
    shader.uniformLocations[SHADER_DST_TF_RANGE]      = glGetUniformLocation(shader.program, "dstTFRange");
    shader.uniformLocations[SHADER_TARGET_PRIMARIES]  = glGetUniformLocation(shader.program, "targetPrimaries");
    shader.uniformLocations[SHADER_MAX_LUMINANCE]     = glGetUniformLocation(shader.program, "maxLuminance");
    shader.uniformLocations[SHADER_DST_MAX_LUMINANCE] = glGetUniformLocation(shader.program, "dstMaxLuminance");
    shader.uniformLocations[SHADER_DST_REF_LUMINANCE] = glGetUniformLocation(shader.program, "dstRefLuminance");
    shader.uniformLocations[SHADER_SDR_SATURATION]    = glGetUniformLocation(shader.program, "sdrSaturation");
    shader.uniformLocations[SHADER_SDR_BRIGHTNESS]    = glGetUniformLocation(shader.program, "sdrBrightnessMultiplier");
    shader.uniformLocations[SHADER_CONVERT_MATRIX]    = glGetUniformLocation(shader.program, "convertMatrix");
}

// shader has #include "rounding.glsl"
static void getRoundingShaderUniforms(SShader& shader) {
    shader.uniformLocations[SHADER_TOP_LEFT]       = glGetUniformLocation(shader.program, "topLeft");
    shader.uniformLocations[SHADER_FULL_SIZE]      = glGetUniformLocation(shader.program, "fullSize");
    shader.uniformLocations[SHADER_RADIUS]         = glGetUniformLocation(shader.program, "radius");
    shader.uniformLocations[SHADER_ROUNDING_POWER] = glGetUniformLocation(shader.program, "roundingPower");
}
</file>

<file path="src/WindowShader.h">
#pragma once

#include "Helpers.h"

#include <hyprland/src/Compositor.hpp>


class WindowShader
{
public:
    void Unload();

    void ShadeIfMatches(PHLWINDOW window);
    void ToggleShade(PHLWINDOW window, const std::string& shader);
    void ForgetWindow(PHLWINDOW window);
    void ReshadeWindows();

    void AddPredefinedShader(const std::string& name);
    ShaderConfig* AddShader(ShaderDefinition def);
    ShaderConfig* EnsureShader(const std::string& shader);

    std::optional<ShaderConfig*>& OnRenderWindowPre(PHLWINDOW window);
    void OnRenderWindowPost();

    using WindowRuleEffect = Desktop::Rule::CWindowRuleEffectContainer::storageType;
    WindowRuleEffect m_RuleShade;

private:
    std::map<std::string, UP<ShaderConfig>> m_Shaders;

    std::map<PHLWINDOW, ShaderConfig*> m_RuleShadedWindows;
    std::map<PHLWINDOW, ShaderConfig*> m_DispatchShadedWindows;

    std::optional<ShaderConfig*> m_ShadersSwapped;
};
</file>

<file path="flake.lock">
{
  "nodes": {
    "aquamarine": {
      "inputs": {
        "hyprutils": [
          "hyprland",
          "hyprutils"
        ],
        "hyprwayland-scanner": [
          "hyprland",
          "hyprwayland-scanner"
        ],
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1745357003,
        "narHash": "sha256-jYwzQkv1r7HN/4qrAuKp+NR4YYNp2xDrOX5O9YVqkWo=",
        "owner": "hyprwm",
        "repo": "aquamarine",
        "rev": "a19cf76ee1a15c1c12083fa372747ce46387289f",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "aquamarine",
        "type": "github"
      }
    },
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1696426674,
        "narHash": "sha256-kvjfFW7WAETZlt09AgDn1MrtKzP7t90Vf7vypd3OL1U=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "0f9255e01c2351cc7d116c072cb317785dd33b33",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "hyprland",
          "pre-commit-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "hyprcursor": {
      "inputs": {
        "hyprlang": [
          "hyprland",
          "hyprlang"
        ],
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1745948457,
        "narHash": "sha256-lzTV10FJTCGNtMdgW5YAhCAqezeAzKOd/97HbQK8GTU=",
        "owner": "hyprwm",
        "repo": "hyprcursor",
        "rev": "ac903e80b33ba6a88df83d02232483d99f327573",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprcursor",
        "type": "github"
      }
    },
    "hyprgraphics": {
      "inputs": {
        "hyprutils": [
          "hyprland",
          "hyprutils"
        ],
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1745015490,
        "narHash": "sha256-apEJ9zoSzmslhJ2vOKFcXTMZLUFYzh1ghfB6Rbw3Low=",
        "owner": "hyprwm",
        "repo": "hyprgraphics",
        "rev": "60754910946b4e2dc1377b967b7156cb989c5873",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprgraphics",
        "type": "github"
      }
    },
    "hyprland": {
      "inputs": {
        "aquamarine": "aquamarine",
        "hyprcursor": "hyprcursor",
        "hyprgraphics": "hyprgraphics",
        "hyprland-protocols": "hyprland-protocols",
        "hyprland-qtutils": "hyprland-qtutils",
        "hyprlang": "hyprlang",
        "hyprutils": "hyprutils",
        "hyprwayland-scanner": "hyprwayland-scanner",
        "nixpkgs": [
          "nixpkgs"
        ],
        "pre-commit-hooks": "pre-commit-hooks",
        "systems": "systems",
        "xdph": "xdph"
      },
      "locked": {
        "lastModified": 1751115313,
        "narHash": "sha256-Ne5qMB/LVWf6RmqY/N1kRhfV3g8bjvWjPkI0PMnWn8c=",
        "ref": "refs/heads/main",
        "rev": "0fea173fc8fc40dbb59b57fc42c03ca2d67d9a8d",
        "revCount": 6230,
        "submodules": true,
        "type": "git",
        "url": "https://github.com/hyprwm/Hyprland"
      },
      "original": {
        "submodules": true,
        "type": "git",
        "url": "https://github.com/hyprwm/Hyprland"
      }
    },
    "hyprland-protocols": {
      "inputs": {
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1743714874,
        "narHash": "sha256-yt8F7NhMFCFHUHy/lNjH/pjZyIDFNk52Q4tivQ31WFo=",
        "owner": "hyprwm",
        "repo": "hyprland-protocols",
        "rev": "3a5c2bda1c1a4e55cc1330c782547695a93f05b2",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprland-protocols",
        "type": "github"
      }
    },
    "hyprland-qt-support": {
      "inputs": {
        "hyprlang": [
          "hyprland",
          "hyprland-qtutils",
          "hyprlang"
        ],
        "nixpkgs": [
          "hyprland",
          "hyprland-qtutils",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "hyprland-qtutils",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1737634706,
        "narHash": "sha256-nGCibkfsXz7ARx5R+SnisRtMq21IQIhazp6viBU8I/A=",
        "owner": "hyprwm",
        "repo": "hyprland-qt-support",
        "rev": "8810df502cdee755993cb803eba7b23f189db795",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprland-qt-support",
        "type": "github"
      }
    },
    "hyprland-qtutils": {
      "inputs": {
        "hyprland-qt-support": "hyprland-qt-support",
        "hyprlang": [
          "hyprland",
          "hyprlang"
        ],
        "hyprutils": [
          "hyprland",
          "hyprland-qtutils",
          "hyprlang",
          "hyprutils"
        ],
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1745951494,
        "narHash": "sha256-2dModE32doiyQMmd6EDAQeZnz+5LOs6KXyE0qX76WIg=",
        "owner": "hyprwm",
        "repo": "hyprland-qtutils",
        "rev": "4be1d324faf8d6e82c2be9f8510d299984dfdd2e",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprland-qtutils",
        "type": "github"
      }
    },
    "hyprlang": {
      "inputs": {
        "hyprutils": [
          "hyprland",
          "hyprutils"
        ],
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1746655412,
        "narHash": "sha256-kVQ0bHVtX6baYxRWWIh4u3LNJZb9Zcm2xBeDPOGz5BY=",
        "owner": "hyprwm",
        "repo": "hyprlang",
        "rev": "557241780c179cf7ef224df392f8e67dab6cef83",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprlang",
        "type": "github"
      }
    },
    "hyprutils": {
      "inputs": {
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1746635225,
        "narHash": "sha256-W9G9bb0zRYDBRseHbVez0J8qVpD5QbizX67H/vsudhM=",
        "owner": "hyprwm",
        "repo": "hyprutils",
        "rev": "674ea57373f08b7609ce93baff131117a0dfe70d",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprutils",
        "type": "github"
      }
    },
    "hyprwayland-scanner": {
      "inputs": {
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1739870480,
        "narHash": "sha256-SiDN5BGxa/1hAsqhgJsS03C3t2QrLgBT8u+ENJ0Qzwc=",
        "owner": "hyprwm",
        "repo": "hyprwayland-scanner",
        "rev": "206367a08dc5ac4ba7ad31bdca391d098082e64b",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "hyprwayland-scanner",
        "type": "github"
      }
    },
    "nix-filter": {
      "locked": {
        "lastModified": 1731533336,
        "narHash": "sha256-oRam5PS1vcrr5UPgALW0eo1m/5/pls27Z/pabHNy2Ms=",
        "owner": "numtide",
        "repo": "nix-filter",
        "rev": "f7653272fd234696ae94229839a99b73c9ab7de0",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "nix-filter",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1748370509,
        "narHash": "sha256-QlL8slIgc16W5UaI3w7xHQEP+Qmv/6vSNTpoZrrSlbk=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "4faa5f5321320e49a78ae7848582f684d64783e9",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "pre-commit-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1746537231,
        "narHash": "sha256-Wb2xeSyOsCoTCTj7LOoD6cdKLEROyFAArnYoS+noCWo=",
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "rev": "fa466640195d38ec97cf0493d6d6882bc4d14969",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "hyprland": "hyprland",
        "nix-filter": "nix-filter",
        "nixpkgs": "nixpkgs"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1689347949,
        "narHash": "sha256-12tWmuL2zgBgZkdoB6qXZsgJEH9LR3oUgpaQq2RbI80=",
        "owner": "nix-systems",
        "repo": "default-linux",
        "rev": "31732fcf5e8fea42e59c2488ad31a0e651500f68",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default-linux",
        "type": "github"
      }
    },
    "xdph": {
      "inputs": {
        "hyprland-protocols": [
          "hyprland",
          "hyprland-protocols"
        ],
        "hyprlang": [
          "hyprland",
          "hyprlang"
        ],
        "hyprutils": [
          "hyprland",
          "hyprutils"
        ],
        "hyprwayland-scanner": [
          "hyprland",
          "hyprwayland-scanner"
        ],
        "nixpkgs": [
          "hyprland",
          "nixpkgs"
        ],
        "systems": [
          "hyprland",
          "systems"
        ]
      },
      "locked": {
        "lastModified": 1745871725,
        "narHash": "sha256-M24SNc2flblWGXFkGQfqSlEOzAGZnMc9QG3GH4K/KbE=",
        "owner": "hyprwm",
        "repo": "xdg-desktop-portal-hyprland",
        "rev": "76bbf1a6b1378e4ab5230bad00ad04bc287c969e",
        "type": "github"
      },
      "original": {
        "owner": "hyprwm",
        "repo": "xdg-desktop-portal-hyprland",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="Makefile">
CXX = g++
CXXFLAGS = -fPIC --no-gnu-unique -Isrc/ -g -std=c++2b -DWLR_USE_UNSTABLE


SRC_DIR = src
OBJ_DIR = out/obj
OUT_DIR = out

SRCS = $(wildcard $(SRC_DIR)/*.cpp)
OBJS = $(patsubst $(SRC_DIR)/%.cpp, $(OBJ_DIR)/%.o, $(SRCS))
DEPS = $(patsubst $(SRC_DIR)/%.cpp, $(OBJ_DIR)/%.d, $(SRCS))

INCLUDES = $(shell pkg-config --cflags pixman-1 libdrm hyprland hyprlang)

TARGET = $(OUT_DIR)/hypr-darkwindow.so

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CXX) -shared $^ -o $@

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp $(OBJ_DIR)/%.d | $(OBJ_DIR)
	$(CXX) $(INCLUDES) $(CXXFLAGS) -MT $@ -MMD -MP -MF $(OBJ_DIR)/$*.d -c $< -o $@

$(OBJ_DIR):
	@mkdir -p $@

$(DEPS):

include $(wildcard $(DEPS))


clean:
	rm -rf $(OUT_DIR)

load: unload $(TARGET)
	hyprctl plugin load $(shell pwd)/$(TARGET)

unload:
	hyprctl plugin unload $(shell pwd)/$(TARGET)

VSC_CONF = .vscode/c_cpp_properties.json
vscode:
	cat <<< $$(jq '.configurations[].includePath = ("$(INCLUDES)"|gsub("(^|(?<= ))-I";"")|split(" "))' $(VSC_CONF)) > $(VSC_CONF)

.PHONY: all vscode clean load unload
</file>

<file path="src/WindowShader.cpp">
#include "WindowShader.h"

#include <hyprutils/string/String.hpp>
#include <hyprland/src/managers/eventLoop/EventLoopManager.hpp>
#include <hyprland/src/helpers/MiscFunctions.hpp>

static const std::map<std::string, std::tuple<std::string, Uniforms, IntroducesTransparency>> WINDOW_SHADER_SOURCES = {
    { "invert", { R"glsl(
        void windowShader(inout vec4 color) {
            // remove premultiplied alpha
            color.rgb /= color.a;

            // Invert Colors
            color.rgb = vec3(1.) - vec3(.88, .9, .92) * color.rgb;

            // Invert Hue
            color.rgb = dot(vec3(0.26312, 0.5283, 0.10488), color.rgb) * 2.0 - color.rgb;

            // remultiply alpha
            color.rgb *= color.a;
        }
    )glsl", {}, {} } },
    // Example for a shader with default uniform values
    { "tint", { R"glsl(
        uniform vec3 tintColor;
        uniform float tintStrength;

        void windowShader(inout vec4 color) {
            // remove premultiplied alpha
            color.rgb /= color.a;

            // tint color
            color.rgb = color.rgb * (1.0 - tintStrength) + tintColor * tintStrength;

            // remultiply alpha
            color.rgb *= color.a;
        }
    )glsl", {
        { "tintColor", { 1, 0, 0 } },
        { "tintStrength", { 0.1 } },
    }, {} } },
    // Original shader by ikz87
    // Applies opacity changes to pixels similar to one color
    { "chromakey", { R"glsl(
        uniform vec3 bkg;
        uniform float similarity; // How many similar colors should be affected.
        uniform float amount; // How much similar colors should be changed.
        uniform float targetOpacity; // Target opacity for similar colors.

        void windowShader(inout vec4 color) {
            if (color.r >= bkg.r - similarity && color.r <= bkg.r + similarity &&
                    color.g >= bkg.g - similarity && color.g <= bkg.g + similarity &&
                    color.b >= bkg.b - similarity && color.b <= bkg.b + similarity) {
                vec3 error = vec3(abs(bkg.r - color.r), abs(bkg.g - color.g), abs(bkg.b - color.b));
                float avg_error = (error.r + error.g + error.b) / 3.0;

                color *= targetOpacity + (1.0 - targetOpacity) * avg_error * amount / similarity;
            }
        }
    )glsl", {
        { "bkg", { 0, 0, 0 } },
        { "similarity", { 0.1 } },
        { "amount", { 1.4 } },
        { "targetOpacity", { 0.83 } },
    }, IntroducesTransparency::Yes } },
};


std::optional<ShaderConfig*>& WindowShader::OnRenderWindowPre(PHLWINDOW window)
{
    m_ShadersSwapped.reset();

    auto ruleShader = m_RuleShadedWindows.find(window);
    auto dispatchShader = m_DispatchShadedWindows.find(window);
    if (ruleShader != m_RuleShadedWindows.end() && dispatchShader != m_DispatchShadedWindows.end())
    {
        if (ruleShader->second->ID != dispatchShader->second->ID)
            m_ShadersSwapped = dispatchShader->second;
    }
    else if (dispatchShader != m_DispatchShadedWindows.end())
        m_ShadersSwapped = dispatchShader->second;
    else if (ruleShader != m_RuleShadedWindows.end())
        m_ShadersSwapped = ruleShader->second;

    if (m_ShadersSwapped) {
        (*m_ShadersSwapped)->CompiledShaders->ApplyArgs((*m_ShadersSwapped)->Args);

        std::swap((*m_ShadersSwapped)->CompiledShaders->EXT, g_pHyprOpenGL->m_shaders->m_shEXT);
        std::swap((*m_ShadersSwapped)->CompiledShaders->RGBA, g_pHyprOpenGL->m_shaders->m_shRGBA);
        std::swap((*m_ShadersSwapped)->CompiledShaders->RGBX, g_pHyprOpenGL->m_shaders->m_shRGBX);
        std::swap((*m_ShadersSwapped)->CompiledShaders->CM, g_pHyprOpenGL->m_shaders->m_shCM);
    }

    return m_ShadersSwapped;
}

void WindowShader::OnRenderWindowPost()
{
    if (m_ShadersSwapped)
    {
        std::swap((*m_ShadersSwapped)->CompiledShaders->EXT, g_pHyprOpenGL->m_shaders->m_shEXT);
        std::swap((*m_ShadersSwapped)->CompiledShaders->RGBA, g_pHyprOpenGL->m_shaders->m_shRGBA);
        std::swap((*m_ShadersSwapped)->CompiledShaders->RGBX, g_pHyprOpenGL->m_shaders->m_shRGBX);
        std::swap((*m_ShadersSwapped)->CompiledShaders->CM, g_pHyprOpenGL->m_shaders->m_shCM);
        m_ShadersSwapped.reset();
    }
}

void WindowShader::Unload()
{
    OnRenderWindowPost();

    m_Shaders.clear();
}

void WindowShader::ShadeIfMatches(PHLWINDOW window)
{
    // for some reason, some events (currently `activeWindow`) sometimes pass a null pointer
    if (!window) return;

    std::optional<std::string> shader;
    auto& props = window->m_ruleApplicator->m_otherProps.props;

    if (const auto& it = props.find(m_RuleShade); it != props.end())
        shader = it->second->effect;

    auto windowIt = m_RuleShadedWindows.find(window);
    std::optional<std::string> currentShader;
    if (windowIt != m_RuleShadedWindows.end()) currentShader = windowIt->second->ID;

    if (shader != currentShader)
    {
        if (shader)
            m_RuleShadedWindows[window] = EnsureShader(*shader);
        else
            m_RuleShadedWindows.erase(window);

        g_pHyprRenderer->damageWindow(window);
    }
}


void WindowShader::ToggleShade(PHLWINDOW window, const std::string& shader)
{
    if (!window)
        return;

    auto windowIt = m_DispatchShadedWindows.find(window);
    std::optional<std::string> currentShader;
    if (windowIt != m_DispatchShadedWindows.end()) currentShader = windowIt->second->ID;

    if (std::optional(shader) != currentShader)
        m_DispatchShadedWindows[window] = EnsureShader(shader);
    else
        m_DispatchShadedWindows.erase(window);

    g_pHyprRenderer->damageWindow(window);
}

void WindowShader::ForgetWindow(PHLWINDOW window)
{
    m_RuleShadedWindows.erase(window);
    m_DispatchShadedWindows.erase(window);
}

void WindowShader::ReshadeWindows()
{
    m_RuleShadedWindows = {};

    for (const auto& window : g_pCompositor->m_windows)
        ShadeIfMatches(window);
}


void WindowShader::AddPredefinedShader(const std::string& name)
{
    static const auto add = [](WindowShader* self, const auto& source) {
        if (self->m_Shaders.contains(source.first)) return;
        auto& [id, options] = source;

        Debug::log(INFO, "Loading predefined shader with name: {}", id);

        UP<ShaderConfig> shader(new ShaderConfig{
            .ID = id,
            .CompiledShaders = SP(new ShaderHolder(std::get<std::string>(options))),
            .Args = std::get<Uniforms>(options),
            .Transparent = std::get<IntroducesTransparency>(options),
        });
        shader->CompiledShaders->PrimeUniforms(shader->Args);

        self->m_Shaders[source.first] = std::move(shader);
    };

    if (name == "all")
    {
        for (const auto& source : WINDOW_SHADER_SOURCES)
        {
            add(this, source);
        }
    }
    else
    {
        auto source = WINDOW_SHADER_SOURCES.find(name);
        if (source == WINDOW_SHADER_SOURCES.end())
            throw efmt("Predefined shader with name {} not found", name);

        add(this, *source);
    }
}

ShaderConfig* WindowShader::AddShader(ShaderDefinition def)
{
    auto found = m_Shaders.find(def.ID);
    if (found != m_Shaders.end()) return found->second.get();

    Debug::log(INFO, "Loading custom shader with id: {}", def.ID);

    UP<ShaderConfig> shader(new ShaderConfig{ .ID = def.ID });

    if (def.From != "")
    {
        if (!m_Shaders.contains(def.From))
            throw efmt("Shader with ID {} has unknown .from shader", def.ID);

        auto& from = m_Shaders[def.From];
        shader->Args = from->Args;
        shader->CompiledShaders = from->CompiledShaders;
        shader->Transparent = from->Transparent;
    }

    if (def.Path != "")
    {
        std::ifstream file(def.Path);
        std::string source = std::string(std::istreambuf_iterator(file), {});

        shader->CompiledShaders = SP(new ShaderHolder(source));
    }

    if (!shader->CompiledShaders)
        throw efmt("Either .from or .path has to be set for Shader with ID {}", def.ID);


    shader->CompiledShaders->PrimeUniforms(def.Args);
    for (auto& [arg, val] : def.Args)
    {
        shader->Args[arg] = val;
    }

    if (def.Transparency) shader->Transparent = IntroducesTransparency::Yes;

    auto ret = shader.get();
    m_Shaders[def.ID] = std::move(shader);
    return ret;
}

ShaderConfig* WindowShader::EnsureShader(const std::string& shader)
{
    size_t space = shader.find(" ");
    if (space == std::string::npos)
    {
        auto found = m_Shaders.find(shader);
        if (found == m_Shaders.end())
            throw efmt("Unable to find shader {}", shader);

        return found->second.get();
    }
    else
    {
        auto from = Hyprutils::String::trim(shader.substr(0, space));
        auto args = shader.substr(space + 1);
        return AddShader({ shader, from, {}, args, {} });
    }
}
</file>

<file path=".github/workflows/notify.yml">
name: Hyprland Breaking Change Notifier

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
  schedule:
    - cron: "0 3 * * *"
  workflow_dispatch: {}

jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: duckonaut/hyprland-arch:latest
    steps:
    - name: Install dependencies
      run: |
        sudo -u user sh -c "paru -Syu --noconfirm aquamarine-git hyprland-git hyprutils-git hyprwayland-scanner-git"
    - name: Checkout current repository
      uses: actions/checkout@v4

    - name: Build current repository
      run: make all
</file>

<file path="src/Helpers.h">
#pragma once

#include <string>
#include <cstring>

#include <hyprland/src/render/Renderer.hpp>
#include <hyprland/src/config/ConfigManager.hpp>
#include <hyprland/src/plugins/PluginAPI.hpp>


template <typename... Args>
inline auto efmt(std::format_string<Args...> fmt, Args&&... args)
{
    return std::runtime_error(std::format(fmt, std::forward<Args>(args)...));
}

inline void notifyError(HANDLE handle, const std::string& err)
{
    std::string msg = std::string("[Hypr-DarkWindow] ") + err;
    Debug::log(ERR, msg);
    HyprlandAPI::addNotification(
        handle,
        msg,
        CHyprColor(0xFFFF0000),
        25'000
    );
}

inline auto findFunction(HANDLE handle, const std::string& className, const std::string& name)
{
    auto all = HyprlandAPI::findFunctionsByName(handle, name);
    auto found = std::find_if(all.begin(), all.end(), [&](const SFunctionMatch& line) {
        return line.demangled.starts_with(className + "::" + name);
    });
    return found != all.end() ? std::optional(*found) : std::optional<SFunctionMatch>();
};

namespace std
{
    inline void swap(SShader& a, SShader& b)
    {
        // memcpy because speed!
        uint8_t c[sizeof(SShader)];
        std::memcpy(&c, &a, sizeof(SShader));
        std::memcpy(&a, &b, sizeof(SShader));
        std::memcpy(&b, &c, sizeof(SShader));
    }
}

using Uniforms = std::map<std::string, std::vector<float>>;
struct ShaderDefinition
{
    ShaderDefinition(std::string id, std::string from, std::string path, const std::string& args, bool transparency);

    std::string ID;
    std::string From;
    std::string Path;
    Uniforms Args;
    bool Transparency;

    Uniforms ParseArgs(const std::string& args);
};

struct ShaderHolder
{
    std::map<std::string, std::array<GLint, 4>> UniformLocations;

    SShader CM;
    SShader RGBA;
    SShader RGBX;
    SShader EXT;

    ShaderHolder(const std::string& source);
    ~ShaderHolder();

    void PrimeUniforms(const Uniforms& args);
    void ApplyArgs(const Uniforms& args) noexcept;
};

enum class IntroducesTransparency { No = 0, Yes};

struct ShaderConfig {
    std::string ID;

    SP<ShaderHolder> CompiledShaders;
    Uniforms Args;
    IntroducesTransparency Transparent;
};
</file>

<file path="flake.nix">
{
  inputs = {
    hyprland.url = "git+https://github.com/hyprwm/Hyprland?submodules=1";

    nix-filter.url = "github:numtide/nix-filter";
  };

  outputs =
    {
      self,
      hyprland,
      nix-filter,
      ...
    }:
    let
      inherit (hyprland.inputs) nixpkgs;
      forHyprlandSystems =
        fn:
        nixpkgs.lib.genAttrs (builtins.attrNames hyprland.packages) (
          system: fn system nixpkgs.legacyPackages.${system}
        );
    in
    {
      packages = forHyprlandSystems (
        system: pkgs:
        let
          hyprlandPackage = hyprland.packages.${system}.hyprland;
        in
        rec {
          Hypr-DarkWindow = pkgs.gcc14Stdenv.mkDerivation {
            pname = "Hypr-DarkWindow";
            version = "5.0.0";
            src = nix-filter.lib {
              root = ./.;
              include = [
                "src"
                ./Makefile
              ];
            };

            nativeBuildInputs = with pkgs; [ pkg-config ];
            buildInputs = [ hyprlandPackage.dev ] ++ hyprlandPackage.buildInputs;

            installPhase = ''
              mkdir -p $out/lib
              install ./out/hypr-darkwindow.so $out/lib/libHypr-DarkWindow.so
            '';

            meta = with pkgs.lib; {
              homepage = "https://github.com/micha4w/Hypr-DarkWindow";
              description = "Apply custom shaders to any Window!";
              license = licenses.mit;
              platforms = platforms.linux;
            };
          };

          default = Hypr-DarkWindow;
        }
      );

      devShells = forHyprlandSystems (
        system: pkgs: {
          default = pkgs.mkShell {
            name = "Hypr-DarkWindow";

            nativeBuildInputs = with pkgs; [
              clang-tools_16
              jq
            ];

            inputsFrom = [ self.packages.${system}.Hypr-DarkWindow ];
          };
        }
      );
    };
}
</file>

<file path="README.md">
# Hypr-DarkWindow

Hyprland plugin that adds possibility to modify the fragment shader of a specific windows.

![preview](./res/preview.png)

## Shaders

There are few shaders already included in this plugin.
All of them get loaded with the plugin, if you want to only load specific ones you can limit the shaders that are loaded.

```ini
plugin:darkwindow:load_shaders = invert,tint # defaults to 'all'
plugin:darkwindow:load_shaders = # dont load any default shaders
```

| **Name**   | **Description**                                                                                              |
| ---------- | ------------------------------------------------------------------------------------------------------------ |
| **invert** | _No uniforms_ <br> Applies smart color inversion                                                             |
| **tint**   | <ul><li>_tintStrength_ = `float` (0-1) </li><li>_tintColor_ = `vec3`</li></ul> Tints the Window <br> |
| **chromakey**   | <ul> <li>_bkg_ = `vec3` <br> The background color of the Window </li> <li>_similarity_ = `float` <br> How many similar colors should be affected</li> <li>_amount_ = `float` <br> How much similar colors should be changed</li> <li>_targetOpacity_ = `float` <br> Target opacity for similar colors</li> </ul> Applies opacity changes to pixels similar to one color <br> |

Feel free to make a pull request if you want to add more shaders ([look here](./src/WindowShader.cpp#L7)).

## Configuration

> [!IMPORTANT]
> BREAKING:
> - WindowRules `invertwindow` and `shadewindow` were removed, use `darkwindow:shade [invert]` instead
> - Shader definition was moved from `darkwindow:shader` to `plugin:darkwindow:shader`
>
> Deprecated:
> - Dispatchers `invert[active]window` and `shade[active]window` will be removed soon, use `darkwindow:shade[active] [invert]` instead

> [!NOTE]
> You can only have one shader applied at the same time.
> Applying a shader to a window which already has one applied will override the first one.

```ini
# hyprland.conf

plugin:darkwindow {
  # To modify the uniforms of an already existing shader, create a new shader and set the uniforms you want
  shader[tintRed] {
      from = tint
      args = tintColor=[1 0 0] tintStrength=0.1
  }

  # Use a custom shader from a file, check out ./src/WindowShader.cpp:7 to see examples for the files content
  shader[cool] {
      path = /path/to/shader.glsl
      args = wow=[1.0 0 0]
      introduces_transparency = true # if you modify the alpha value make sure to set this value to true so hyprland knows it should enable blur
  }
}

# Then to apply the shader to a window you can use window rules
windowrule = darkwindow:shade invert, match:class (pb170.exe)
# Uniforms can also be passed on the fly, but make sure to not use commas inside the arrays
windowrule = darkwindow:shade tint tintColor=[0 1 0], match:fullscreen true

# Or use a dispatcher
bind = $mainMod, T, darkwindow:shadeactive, tint tintColor=[0 0.5 1] tintStrength=0.3
# There is also a `darkwindow:shade WINDOW_REGEX SHADER_NAME` available (see window in https://wiki.hypr.land/Configuring/Dispatchers/#parameter-explanation)
```

## Installation

### hyprpm
```sh
hyprpm add https://github.com/micha4w/Hypr-DarkWindow
hyprpm enable Hypr-DarkWindow
hyprpm reload
```

### NixOS (home-manager)
You should already have a fully working home-manager setup before adding this plugin.
```nix
#flake.nix
inputs = {
    home-manager = { ... };
    hyprland = { ... };
    ...
    hypr-darkwindow = {
      url = "github:micha4w/Hypr-DarkWindow/tags/v0.36.0"; # Make sure to change the tag to match your hyprland version
      inputs.hyprland.follows = "hyprland";
    };
};

outputs = {
  home-manager,
  hypr-darkwindow,
  ...
}: {
  ... = {
    home-manager.users.micha4w = {
      wayland.windowManager.hyprland.plugins = [
        hypr-darkwindow.packages.${pkgs.system}.Hypr-DarkWindow
      ];
    };
  };
}
```
</file>

<file path="src/Helpers.cpp">
#include "Helpers.h"

#include <exception>
#include <unordered_set>
#include <ranges>

#include <hyprland/src/Compositor.hpp>
#include <hyprutils/utils/ScopeGuard.hpp>

#include "OpenGL.cpp.h"
#include "src/render/Shader.hpp"


static std::string editShader(std::string source, const std::string& windowShader) {
    size_t out = source.find("layout(location = 0) out vec4 ");
    std::string outVar;
    if (out != std::string::npos) {
        // es 300
        size_t endOut = source.find(";", out);
        outVar = std::string(&source[out + sizeof("layout(location = 0) out vec4 ") - 1], &source[endOut]);
        outVar = Hyprutils::String::trim(outVar);
    } else {
        // es 200
        if (!source.contains("gl_FragColor")) {
            Debug::log(ERR, "Failed to edit GLSL Code, no gl_FragColor:\n{}", source);
            throw efmt("Frag source does not contain a usage of 'gl_FragColor'");
        }

        outVar = "gl_FragColor";
    }

    if (!source.contains("void main(")) {
        Debug::log(ERR, "Failed to edit GLSL Code, no main function: {}", source);
        throw efmt("Frag source does not contain an occurence of 'void main('");
    }

    Hyprutils::String::replaceInString(source, "void main(", "void main_unshaded(");

    source += windowShader + R"glsl(

void main() {
    main_unshaded();

    windowShader()glsl" + outVar + ");\n}";


    return source;
}

ShaderDefinition::ShaderDefinition(std::string id, std::string from, std::string path, const std::string& args, bool transparency)
    : ID(id), From(from), Path(path), Transparency(transparency)
{
    try
    {
        Args = ParseArgs(args);
    }
    catch (const std::exception& ex)
    {
        throw efmt("Failed to parse arguments of shader '{}': {}", args, ex.what());
    }
}

Uniforms ShaderDefinition::ParseArgs(const std::string& args)
{
    Uniforms out;
    std::stringstream ss(args);

    ss >> std::ws;
    while (!ss.eof())
    {
        std::string name;
        std::getline(ss, name, '=');
        name = Hyprutils::String::trim(name);
        for (auto [i, c] : std::views::enumerate(name))
        {
            bool first = c>='a' && c<='z' || c>='A' && c<='Z' || c=='_';
            bool other = c>='0' && c<='9';

            if (!(first || other && i != 0))
                throw efmt("invalid shader uniform name '{}'", name);
        }

        ss >> std::ws;
        
        std::vector<float> values;
        if (ss.peek() == '[')
        {
            ss.get();
            while (1)
            {
                std::string rem(ss.str().substr(ss.tellg()));

                float next;
                ss >> next;

                if (ss.fail()) break;
                values.push_back(next);

                ss >> std::ws;
                if (ss.peek() == ',')
                {
                    ss.get();
                    ss >> std::ws;
                }
                if (ss.peek() == ']') {
                    ss.get();
                    break;
                }

                if (ss.eof()) throw efmt("expected ']' not found");
            }

            if (values.size() < 1 || values.size() > 4)
                throw efmt("only support from 1 to 4 values");
        }
        else
        {
            float next;
            ss >> next;
            values.push_back(next);
        }
        if (ss.fail()) throw efmt("expected a float");
        ss >> std::ws;

        out[name] = values;
    }

    return out;
}

void ShaderHolder::PrimeUniforms(const Uniforms& args)
{
    g_pHyprRenderer->makeEGLCurrent();
    Hyprutils::Utils::CScopeGuard _egl([&]{ g_pHyprRenderer->unsetEGL(); });

    for (auto& [name, _] : args)
    {
        if (UniformLocations.contains(name)) continue;

        SShader* shaders[4] = { &CM, &RGBA, &RGBX, &EXT };
        std::array<GLint, 4> locs;
        for (int i = 0; i < 4; i++)
        {
            if (!shaders[i]->program) continue;

            GLint loc = glGetUniformLocation(shaders[i]->program, name.c_str());
            if (loc == -1) throw efmt("Shader failed to find the uniform: {}", name);
            locs[i] = loc;
        }

        UniformLocations[name] = locs;
    }
}

void ShaderHolder::ApplyArgs(const Uniforms& args) noexcept
{
    GLint prog;
    glGetIntegerv(GL_CURRENT_PROGRAM, &prog);

    SShader* shaders[4] = { &CM, &RGBA, &RGBX, &EXT };
    for (int i = 0; i < 4; i++)
    {
        if (!shaders[i]->program) continue;

        glUseProgram(shaders[i]->program);
        for (auto& [name, values] : args)
        {
            GLint loc = UniformLocations[name][i];
            switch (values.size())
            {
                case 1:
                    glUniform1f(loc, values[0]);
                    break;
                case 2:
                    glUniform2f(loc, values[0], values[1]);
                    break;
                case 3:
                    glUniform3f(loc, values[0], values[1], values[2]);
                    break;
                case 4:
                    glUniform4f(loc, values[0], values[1], values[2], values[3]);
                    break;
            }
        }
    }

    glUseProgram(prog);
}


ShaderHolder::ShaderHolder(const std::string& source)
{
    g_pHyprRenderer->makeEGLCurrent();
    Hyprutils::Utils::CScopeGuard _egl([&]{ g_pHyprRenderer->unsetEGL(); });

    std::map<std::string, std::string> includes;
    loadShaderInclude("rounding.glsl", includes);
    loadShaderInclude("CM.glsl", includes);

    const auto& TEXVERTSRC             = g_pHyprOpenGL->m_shaders->TEXVERTSRC;

    const auto TEXFRAGSRCCM           = editShader(processShader("CM.frag", includes), source);
    const auto TEXFRAGSRCRGBA         = editShader(processShader("rgba.frag", includes), source);
    const auto TEXFRAGSRCRGBX         = editShader(processShader("rgbx.frag", includes), source);
    const auto TEXFRAGSRCEXT          = editShader(processShader("ext.frag", includes), source);

    CM.program = createProgram(TEXVERTSRC, TEXFRAGSRCCM, true, true);
    if (CM.program) {
        getCMShaderUniforms(CM);
        getRoundingShaderUniforms(CM);

        CM.uniformLocations[SHADER_PROJ]                = glGetUniformLocation(CM.program, "proj");
        CM.uniformLocations[SHADER_TEX]                 = glGetUniformLocation(CM.program, "tex");
        CM.uniformLocations[SHADER_TEX_TYPE]            = glGetUniformLocation(CM.program, "texType");
        CM.uniformLocations[SHADER_ALPHA_MATTE]         = glGetUniformLocation(CM.program, "texMatte");
        CM.uniformLocations[SHADER_ALPHA]               = glGetUniformLocation(CM.program, "alpha");
        CM.uniformLocations[SHADER_TEX_ATTRIB]          = glGetAttribLocation(CM.program, "texcoord");
        CM.uniformLocations[SHADER_MATTE_TEX_ATTRIB]    = glGetAttribLocation(CM.program, "texcoordMatte");
        CM.uniformLocations[SHADER_POS_ATTRIB]          = glGetAttribLocation(CM.program, "pos");
        CM.uniformLocations[SHADER_DISCARD_OPAQUE]      = glGetUniformLocation(CM.program, "discardOpaque");
        CM.uniformLocations[SHADER_DISCARD_ALPHA]       = glGetUniformLocation(CM.program, "discardAlpha");
        CM.uniformLocations[SHADER_DISCARD_ALPHA_VALUE] = glGetUniformLocation(CM.program, "discardAlphaValue");
        CM.uniformLocations[SHADER_APPLY_TINT]          = glGetUniformLocation(CM.program, "applyTint");
        CM.uniformLocations[SHADER_TINT]                = glGetUniformLocation(CM.program, "tint");
        CM.uniformLocations[SHADER_USE_ALPHA_MATTE]     = glGetUniformLocation(CM.program, "useAlphaMatte");
        CM.createVao();
    } else {
        if (g_pHyprOpenGL->m_shaders->m_shCM.program)
            throw efmt("Failed to create Shader: CM.frag, check hyprland logs");
    }

    RGBA.program = createProgram(TEXVERTSRC, TEXFRAGSRCRGBA, true, true);
    if (!RGBA.program) throw efmt("Failed to create Shader: rgba.frag, check hyprland logs");
    getRoundingShaderUniforms(RGBA);
    RGBA.uniformLocations[SHADER_PROJ]                = glGetUniformLocation(RGBA.program, "proj");
    RGBA.uniformLocations[SHADER_TEX]                 = glGetUniformLocation(RGBA.program, "tex");
    RGBA.uniformLocations[SHADER_ALPHA_MATTE]         = glGetUniformLocation(RGBA.program, "texMatte");
    RGBA.uniformLocations[SHADER_ALPHA]               = glGetUniformLocation(RGBA.program, "alpha");
    RGBA.uniformLocations[SHADER_TEX_ATTRIB]          = glGetAttribLocation(RGBA.program, "texcoord");
    RGBA.uniformLocations[SHADER_MATTE_TEX_ATTRIB]    = glGetAttribLocation(RGBA.program, "texcoordMatte");
    RGBA.uniformLocations[SHADER_POS_ATTRIB]          = glGetAttribLocation(RGBA.program, "pos");
    RGBA.uniformLocations[SHADER_DISCARD_OPAQUE]      = glGetUniformLocation(RGBA.program, "discardOpaque");
    RGBA.uniformLocations[SHADER_DISCARD_ALPHA]       = glGetUniformLocation(RGBA.program, "discardAlpha");
    RGBA.uniformLocations[SHADER_DISCARD_ALPHA_VALUE] = glGetUniformLocation(RGBA.program, "discardAlphaValue");
    RGBA.uniformLocations[SHADER_APPLY_TINT]          = glGetUniformLocation(RGBA.program, "applyTint");
    RGBA.uniformLocations[SHADER_TINT]                = glGetUniformLocation(RGBA.program, "tint");
    RGBA.uniformLocations[SHADER_USE_ALPHA_MATTE]     = glGetUniformLocation(RGBA.program, "useAlphaMatte");
    RGBA.createVao();

    RGBX.program = createProgram(TEXVERTSRC, TEXFRAGSRCRGBX, true, true);
    if (!RGBX.program) throw efmt("Failed to create Shader: rgbx.frag, check hyprland logs");
    getRoundingShaderUniforms(RGBX);
    RGBX.uniformLocations[SHADER_TEX]                 = glGetUniformLocation(RGBX.program, "tex");
    RGBX.uniformLocations[SHADER_PROJ]                = glGetUniformLocation(RGBX.program, "proj");
    RGBX.uniformLocations[SHADER_ALPHA]               = glGetUniformLocation(RGBX.program, "alpha");
    RGBX.uniformLocations[SHADER_TEX_ATTRIB]          = glGetAttribLocation(RGBX.program, "texcoord");
    RGBX.uniformLocations[SHADER_POS_ATTRIB]          = glGetAttribLocation(RGBX.program, "pos");
    RGBX.uniformLocations[SHADER_DISCARD_OPAQUE]      = glGetUniformLocation(RGBX.program, "discardOpaque");
    RGBX.uniformLocations[SHADER_DISCARD_ALPHA]       = glGetUniformLocation(RGBX.program, "discardAlpha");
    RGBX.uniformLocations[SHADER_DISCARD_ALPHA_VALUE] = glGetUniformLocation(RGBX.program, "discardAlphaValue");
    RGBX.uniformLocations[SHADER_APPLY_TINT]          = glGetUniformLocation(RGBX.program, "applyTint");
    RGBX.uniformLocations[SHADER_TINT]                = glGetUniformLocation(RGBX.program, "tint");
    RGBX.createVao();

    EXT.program = createProgram(TEXVERTSRC, TEXFRAGSRCEXT, true, true);
    if (!EXT.program) throw efmt("Failed to create Shader: ext.frag, check hyprland logs");
    getRoundingShaderUniforms(EXT);
    EXT.uniformLocations[SHADER_TEX]                 = glGetUniformLocation(EXT.program, "tex");
    EXT.uniformLocations[SHADER_PROJ]                = glGetUniformLocation(EXT.program, "proj");
    EXT.uniformLocations[SHADER_ALPHA]               = glGetUniformLocation(EXT.program, "alpha");
    EXT.uniformLocations[SHADER_POS_ATTRIB]          = glGetAttribLocation(EXT.program, "pos");
    EXT.uniformLocations[SHADER_TEX_ATTRIB]          = glGetAttribLocation(EXT.program, "texcoord");
    EXT.uniformLocations[SHADER_DISCARD_OPAQUE]      = glGetUniformLocation(EXT.program, "discardOpaque");
    EXT.uniformLocations[SHADER_DISCARD_ALPHA]       = glGetUniformLocation(EXT.program, "discardAlpha");
    EXT.uniformLocations[SHADER_DISCARD_ALPHA_VALUE] = glGetUniformLocation(EXT.program, "discardAlphaValue");
    EXT.uniformLocations[SHADER_APPLY_TINT]          = glGetUniformLocation(EXT.program, "applyTint");
    EXT.uniformLocations[SHADER_TINT]                = glGetUniformLocation(EXT.program, "tint");
    EXT.createVao();
}

ShaderHolder::~ShaderHolder()
{
    g_pHyprRenderer->makeEGLCurrent();

    CM.destroy();
    RGBA.destroy();
    RGBX.destroy();
    EXT.destroy();

    g_pHyprRenderer->unsetEGL();
}
</file>

<file path="src/main.cpp">
#include <hyprland/src/render/pass/PassElement.hpp>

#define private public
#include <hyprland/src/render/pass/SurfacePassElement.hpp>
#undef private

#define m_failedPluginConfigValues    m_failedPluginConfigValues; friend struct ConfigManagerFriend;
#include <hyprland/src/config/ConfigManager.hpp>
#undef m_failedPluginConfigValues

#include <hyprutils/string/ConstVarList.hpp>
#include <hyprutils/string/String.hpp>


#include "WindowShader.h"

#include <mutex>
#include <vector>

#include <dlfcn.h>

#include <hyprlang.hpp>

struct ConfigManagerFriend {
    static auto& GetConfig() {
        return g_pConfigManager->m_config;
    }
};


inline HANDLE PHANDLE = nullptr;

inline WindowShader g_WindowShader;
inline std::mutex g_ShaderMutex;

inline WindowShader::WindowRuleEffect g_RuleShade;

inline std::vector<SP<HOOK_CALLBACK_FN>> g_Callbacks;
CFunctionHook* g_surfacePassDraw;

// TODO check out transformers

void hkSurfacePassDraw(CSurfacePassElement* thisptr, const CRegion& damage) {
    {
        std::lock_guard<std::mutex> lock(g_ShaderMutex);
        auto shader = g_WindowShader.OnRenderWindowPre(thisptr->m_data.pWindow);
        if (shader && (*shader)->Transparent == IntroducesTransparency::Yes) {
            // TODO: undo these changes?
            thisptr->m_data.blur = true;
            if (thisptr->m_data.texture) thisptr->m_data.texture->m_opaque = false;
            if (thisptr->m_data.surface && !thisptr->m_data.surface->m_current.opaque.empty())
            {
                thisptr->m_data.surface->m_current.opaque.clear();
                // TODO: For some reason we need to damage the window twice?
                g_pHyprRenderer->damageWindow(thisptr->m_data.pWindow);
            }
        }
    }

    ((decltype(&hkSurfacePassDraw))g_surfacePassDraw->m_original)(thisptr, damage);

    {
        std::lock_guard<std::mutex> lock(g_ShaderMutex);
        g_WindowShader.OnRenderWindowPost();
    }
}


const char* SHADER_CATEGORY = "plugin:darkwindow:shader";
const char* LOAD_SHADERS_KEY = "plugin:darkwindow:load_shaders";

APICALL EXPORT PLUGIN_DESCRIPTION_INFO PLUGIN_INIT(HANDLE handle)
{
    PHANDLE = handle;

    // check that header version aligns with running version
    const std::string CLIENT_HASH = __hyprland_api_get_client_hash();
    const std::string COMPOSITOR_HASH = __hyprland_api_get_hash();
    if (COMPOSITOR_HASH != CLIENT_HASH) {
        notifyError(PHANDLE, "Failed to load, mismatched versions! (see logs)");
        throw efmt("version mismatch, built against {}, running compositor {}", CLIENT_HASH, COMPOSITOR_HASH);
    }

    Debug::log(INFO, "[Hypr-DarkWindow] Loading Plugin");

    {
        auto& config = ConfigManagerFriend::GetConfig();
        config->addSpecialCategory(SHADER_CATEGORY, { .key = "id", });
        config->addSpecialConfigValue(SHADER_CATEGORY, "from", "");
        config->addSpecialConfigValue(SHADER_CATEGORY, "path", "");
        config->addSpecialConfigValue(SHADER_CATEGORY, "args", "");
        config->addSpecialConfigValue(SHADER_CATEGORY, "introduces_transparency", Hyprlang::INT{ 0 });
    }

    HyprlandAPI::addConfigValue(PHANDLE, LOAD_SHADERS_KEY, Hyprlang::STRING("all"));

    g_RuleShade = Desktop::Rule::windowEffects()->registerEffect("darkwindow:shade");

    g_Callbacks = {};
    g_Callbacks.push_back(HyprlandAPI::registerCallbackDynamic(
        PHANDLE, "configReloaded",
        [&](void* self, SCallbackInfo&, std::any data) {
            if (!g_pHyprOpenGL->m_shadersInitialized) {
                Debug::log(WARN, "[Hypr-DarkWindow] Initializing shaders since they havent been initialized by Hyprland yet");
                g_pHyprOpenGL->initShaders();
            }

            std::lock_guard<std::mutex> lock(g_ShaderMutex);

            g_WindowShader = WindowShader();
            g_WindowShader.m_RuleShade = g_RuleShade;

            Hyprutils::String::CConstVarList list(
                (Hyprlang::STRING) HyprlandAPI::getConfigValue(PHANDLE, LOAD_SHADERS_KEY)->dataPtr()
            );
            for (auto& _name : list)
            {
                std::string name(_name);
                try
                {
                    g_WindowShader.AddPredefinedShader(name);
                }
                catch (const std::exception& ex)
                {
                    notifyError(PHANDLE, std::string("Failed to load predefined shader ") + name + ": " + ex.what());
                }
            }

            auto& config = ConfigManagerFriend::GetConfig();

            auto ids = config->listKeysForSpecialCategory(SHADER_CATEGORY);
            for (auto& id : std::set<std::string>(ids.begin(), ids.end()))
            {
                auto name = std::any_cast<Hyprlang::STRING>(
                    config->getSpecialConfigValue(SHADER_CATEGORY, "from", id.c_str()));
                auto path = std::any_cast<Hyprlang::STRING>(
                    config->getSpecialConfigValue(SHADER_CATEGORY, "path", id.c_str()));
                auto args = std::any_cast<Hyprlang::STRING>(
                    config->getSpecialConfigValue(SHADER_CATEGORY, "args", id.c_str()));
                auto transparent = std::any_cast<Hyprlang::INT>(
                    config->getSpecialConfigValue(SHADER_CATEGORY, "introduces_transparency", id.c_str()));

                try
                {
                    g_WindowShader.AddShader({ id, name, path, args, transparent > 0 });
                }
                catch (const std::exception& ex)
                {
                    notifyError(PHANDLE, std::string("Failed to load custom shader ") + SHADER_CATEGORY + "[" + id + "]: " + ex.what());
                }
            }

            Debug::log(INFO, "[Hypr-DarkWindow] Compiled all shaders");
            try
            {
                g_WindowShader.ReshadeWindows();
            }
            catch (const std::exception& ex)
            {
                notifyError(PHANDLE, std::string("Failed to apply window rule shader: ") + ex.what());
            }
        }
    ));

    g_pConfigManager->reload();

    g_Callbacks.push_back(HyprlandAPI::registerCallbackDynamic(
        PHANDLE, "closeWindow",
        [&](void* self, SCallbackInfo&, std::any data) {
            std::lock_guard<std::mutex> lock(g_ShaderMutex);
            g_WindowShader.ForgetWindow(std::any_cast<PHLWINDOW>(data));
        }
    ));
    g_Callbacks.push_back(HyprlandAPI::registerCallbackDynamic(
        PHANDLE, "windowUpdateRules",
        [&](void* self, SCallbackInfo&, std::any data) {
            std::lock_guard<std::mutex> lock(g_ShaderMutex);
            try
            {
                g_WindowShader.ShadeIfMatches(std::any_cast<PHLWINDOW>(data));
            }
            catch (const std::exception& ex)
            {
                notifyError(PHANDLE, std::string("Failed to apply window rule shader: ") + ex.what());
            }
        }
    ));

    static const auto pDraw = findFunction(PHANDLE, "CSurfacePassElement", "draw");
    if (!pDraw) throw efmt("Failed to find CSurfacePassElement::draw");
    g_surfacePassDraw = HyprlandAPI::createFunctionHook(handle, pDraw->address, (void*)&hkSurfacePassDraw);
    g_surfacePassDraw->hook();

    const auto rescue = [&](auto f) {
        return [&](std::string args) {
            std::lock_guard<std::mutex> lock(g_ShaderMutex);
            try
            {
                f(args);
                return SDispatchResult{};
            }
            catch (const std::exception& ex)
            {
                notifyError(PHANDLE, std::format("Exception in dispatcher: {}", ex.what()));
                return SDispatchResult{ .success = false, .error = ex.what() };
            }
        };
    };

    const auto shade = rescue([&](std::string args) {
        g_WindowShader.ToggleShade(g_pCompositor->m_lastWindow.lock(), args);
    });
    const auto shadeSpecific = rescue([&](std::string args) {
        size_t space = args.find(" ");
        if (space == std::string::npos) throw efmt("Expected 2 Arguments: <WINDOW> <SHADER>");
        g_WindowShader.ToggleShade(g_pCompositor->getWindowByRegex(args.substr(0, space)), args.substr(space + 1));
    });

    HyprlandAPI::addDispatcherV2(PHANDLE, "darkwindow:shade", shadeSpecific);
    HyprlandAPI::addDispatcherV2(PHANDLE, "darkwindow:shadeactive", shade);

    // Keep these keywords because backwards compatibility :)
    HyprlandAPI::addDispatcherV2(PHANDLE, "shadeactivewindow", shade);
    HyprlandAPI::addDispatcherV2(PHANDLE, "shadewindow", shadeSpecific);
    HyprlandAPI::addDispatcherV2(PHANDLE, "invertactivewindow", [&](std::string args) { return shade("invert"); });
    HyprlandAPI::addDispatcherV2(PHANDLE, "invertwindow", [&](std::string args) { return shadeSpecific(args + " invert"); });

    return {
        "Hypr-DarkWindow",
        "Allows you to set dark mode for only specific Windows",
        "micha4w",
        "5.0.0"
    };
}

APICALL EXPORT void PLUGIN_EXIT()
{
    std::lock_guard<std::mutex> lock(g_ShaderMutex);
    g_Callbacks = {};
    g_WindowShader.Unload();

    auto& config = ConfigManagerFriend::GetConfig();
    config->removeSpecialConfigValue(SHADER_CATEGORY, "from");
    config->removeSpecialConfigValue(SHADER_CATEGORY, "path");
    config->removeSpecialConfigValue(SHADER_CATEGORY, "args");
    config->removeSpecialConfigValue(SHADER_CATEGORY, "introduces_transparency");
    config->removeSpecialCategory(SHADER_CATEGORY);

    Desktop::Rule::windowEffects()->unregisterEffect(g_RuleShade);
}

APICALL EXPORT std::string PLUGIN_API_VERSION()
{
    return HYPRLAND_API_VERSION;
}
</file>

<file path="hyprpm.toml">
[repository]
name = "Hypr-DarkWindow"
authors = ["micha4w"]
commit_pins = [
    # v Hyprland                                  v Hypr-DarkWindow
    ["1c460e98f870676b15871fe4e5bfeb1a32a3d6d8", "7eb7e04dea8cb92f22b7c2df4c78d4f29e28643d"], # v0.36.0
    ["19c90048d65a5660384d2fb865926a366696d6be", "7eb7e04dea8cb92f22b7c2df4c78d4f29e28643d"], # v0.37.0
    ["c5e28ebcfe00a510922779b2c568cfa52a317445", "7eb7e04dea8cb92f22b7c2df4c78d4f29e28643d"], # v0.37.1
    ["3875679755014997776e091ff8903acfb311dd2f", "c506360835a3049ec01b33ef0fdab13a1e20d314"], # v0.38.0
    ["360ede79d124ffdeebbe8401f1ac4bc0dbec2c91", "c506360835a3049ec01b33ef0fdab13a1e20d314"], # v0.38.1
    ["e93fbd7c4f991cb8ef03e433ccc4d43587923e15", "e847f179adf4eab3517623e3d5209f531435a61a"], # v0.39.0
    ["fe7b748eb668136dd0558b7c8279bfcd7ab4d759", "e847f179adf4eab3517623e3d5209f531435a61a"], # v0.39.1
    ["cba1ade848feac44b2eda677503900639581c3f4", "a0d1964d91e59ba9199991ddcece48a56dcb3fc9"], # v0.40.0
    ["ea2501d4556f84d3de86a4ae2f4b22a474555b9f", "d1c4337676d618db7199e4717c59807b4cafac5e"], # v0.41.0
    ["9e781040d9067c2711ec2e9f5b47b76ef70762b3", "ad5cb981f801e32b576617ec9290c282304c30d4"], # v0.41.1
    ["918d8340afd652b011b937d29d5eea0be08467f5", "ad5cb981f801e32b576617ec9290c282304c30d4"], # v0.41.2
    ["9a09eac79b85c846e3a865a9078a3f8ff65a9259", "58bb4f967c58334a1d6dbe0ab2442ac8984d2ac6"], # v0.42.0
    ["0f594732b063a90d44df8c5d402d658f27471dfe", "cf6795a382826218411c614b9c2d11c6bb78a368"], # v0.43.0
    ["0c7a7e2d569eeed9d6025f3eef4ea0690d90845d", "cf6795a382826218411c614b9c2d11c6bb78a368"], # v0.44.0
    ["4520b30d498daca8079365bdb909a8dea38e8d55", "dde4f7f14c3a51f244e3e8a197b468a424b39d14"], # v0.44.1
    ["a425fbebe4cf4238e48a42f724ef2208959d66cf", "8fae7b5698379be08ea61a2e7a3349da0b930a94"], # v0.45.0
    ["500d2a3580388afc8b620b0a3624147faa34f98b", "8fae7b5698379be08ea61a2e7a3349da0b930a94"], # v0.45.1
    ["12f9a0d0b93f691d4d9923716557154d74777b0a", "8fae7b5698379be08ea61a2e7a3349da0b930a94"], # v0.45.2
    ["788ae588979c2a1ff8a660f16e3c502ef5796755", "98ae7daf09a5c03e0595bc55e46059cc81d426d6"], # v0.46.0
    ["254fc2bc6000075f660b4b8ed818a6af544d1d64", "98ae7daf09a5c03e0595bc55e46059cc81d426d6"], # v0.46.1
    ["0bd541f2fd902dbfa04c3ea2ccf679395e316887", "98ae7daf09a5c03e0595bc55e46059cc81d426d6"], # v0.46.2
    ["04ac46c54357278fc68f0a95d26347ea0db99496", "ae5725442267ae7ae417ca2b27840b0f84edcf78"], # v0.47.0
    ["75dff7205f6d2bd437abfb4196f700abee92581a", "ae5725442267ae7ae417ca2b27840b0f84edcf78"], # v0.47.1
    ["882f7ad7d2bbfc7440d0ccaef93b1cdd78e8e3ff", "ae5725442267ae7ae417ca2b27840b0f84edcf78"], # v0.47.2
    ["5ee35f914f921e5696030698e74fb5566a804768", "2d2e7ebac5c52cb23f3cbf06052ceba47a73802d"], # v0.48.0
    ["29e2e59fdbab8ed2cc23a20e3c6043d5decb5cdc", "2d2e7ebac5c52cb23f3cbf06052ceba47a73802d"], # v0.48.1
    ["9958d297641b5c84dcff93f9039d80a5ad37ab00", "26300e4b5358899d060edfbc426bd1ecce670ae5"], # v0.49.0
    ["c4a4c341568944bd4fb9cd503558b2de602c0213", "c1cdd7146b18a9fcc8095817ef4c4711d4389464"], # v0.50.0
    ["4e242d086e20b32951fdc0ebcbfb4d41b5be8dcc", "c1cdd7146b18a9fcc8095817ef4c4711d4389464"], # v0.50.1
    ["46174f78b374b6cea669c48880877a8bdcf7802f", "c1cdd7146b18a9fcc8095817ef4c4711d4389464"], # v0.51.0
    ["71a1216abcc7031776630a6d88f105605c4dc1c9", "c1cdd7146b18a9fcc8095817ef4c4711d4389464"], # v0.51.1
    ["f56ec180d3a03a5aa978391249ff8f40f949fb73", "744f3c69cfc33b3ddb5902000807b80425139ef6"], # v0.52.0
    ["967c3c7404d4fa00234e29c70df3e263386d2597", "744f3c69cfc33b3ddb5902000807b80425139ef6"], # v0.52.1

]

[Hypr-DarkWindow]
description = "Apply custom shaders to any Window!"
authors = ["micha4w"]
output = "out/hypr-darkwindow.so"
build = [
    "make all -j",
]
</file>

</files>
